# -*- coding: utf-8 -*-
"""Gran_Tarea2BraitherDiaz

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19Xj0He-QlpNdsp9RMijznE_cutH3A0RA

# Gran Tarea 2

A partir de la soluci√≥n a la ecuaci√≥n de ‚ÄúLane-Emden‚Äù:

$$\frac{1}{\xi^2}\dfrac{d}{d\xi}\left [ \xi^2 \dfrac{d\theta}{d\xi} \right] = - \theta^n$$

Encuentre, para diferentes √≠ndices politr√≥picos, las variables de estructura estelar: radio, masa, densidad y presi√≥n.
"""

#Importemos algunas librerias
from google.colab import drive
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import math
import astropy
from astropy import units as u
from astropy import constants as const
from prettytable import PrettyTable

#Modificamos la potenciaci√≥n puesto que cuando queremos calcular el resultado
#de un valor negativo elevado a una potencia fraccionaria impar, no obtenemos
#la raiz real si no una compleja.
def pot(x, n):
    return math.copysign(abs(x)**(n), x)

"""Para solucionar esta ecuaci√≥n diferencial ordinaria debemos transformar el problema de la siguiente forma:

$$y =  \xi^2 \dfrac{d\theta}{d\xi}$$
$$\dfrac{dy}{d\xi} = - \xi^2\theta^n$$
$$dy = - \xi^2\theta^n d\xi$$
$$y = - \int\xi^2\theta^n d\xi$$

Y adem√°s:

$$\xi^2 \dfrac{d\theta}{d\xi} = y$$
$$\dfrac{d\theta}{d\xi} = \xi^{-2} y$$
$$d\theta = \xi^{-2}yd\xi$$
$$\theta = \int\xi^{-2}yd\xi$$

De esta forma, debemos calcular primero una de las integrales y utilizando los valores obtenidos, podemos calcular la otra integral.
Ahora realicemos las correspondientes integraciones num√©ricas.

Queremos determinar las variables de la estructura estelar:

$$r(\xi) = \left [\frac{(n + 1)K_n}{4\pi G} \right]^{1/2} \lambda^{\frac{1-n}{2n}} \xi$$
$$M(\xi) = -4\pi\left [\frac{(n + 1)K_n}{4\pi G} \right]^{3/2} \lambda^{\frac{3-n}{2n}} \xi^2 \dfrac{d\theta}{d\xi}$$
$$\rho(\xi) = \lambda\theta^n$$
$$P(\xi) = K_n\lambda^{\frac{n+1}{n}} \theta^{n+1} = W_n \frac{GM^2_*}{R^4_*}$$

Pero antes, debemos determinar:
$$\lambda = \rho_c = - \left [ \frac{\xi}{3} \frac{1}{\left(\dfrac{d\theta}{d\xi} \right)}\right]_{\xi=\xi_1}\bar\rho$$
$$W_n = \frac{1}{4\pi(n+1)\left[\left( \dfrac{d\theta}{d\xi} \right)_{\xi=\xi_1}\right]^2}$$
$$\omega_{0,n} = - \left[ \xi^{\frac{n+1}{n-1}} \left( \dfrac{d\theta}{d\xi} \right) \right]_{\xi=\xi_1}$$
$$N_n = \frac{1}{n+1} \left [ \frac{4\pi}{\omega^{n-1}_{0,n}} \right]^{1/n}$$
$$K_n = N_nG_*M^{\frac{n-1}{n}}_*R^{\frac{3-n}{n}}_*$$

Para poder determinar cualquiera de estos valores, se necesita el primer cero de cada √≠ndice $\xi_1$, si es que tiene alg√∫n cero, y $\dfrac{d\theta}{d\xi}$ evaluada en $\xi_1$. Recordemos que:

$$\dfrac{d\theta}{d\xi}= y \frac{1}{\xi^2} $$
"""

dxi = 0.001
N = 400000 #2482

#Definimos algunas constantes
G = np.float64(const.G)       #Constante de Cavendish
M_s = np.float64(const.M_sun) #Masa sol
R_s = np.float64(const.R_sun) #Radio sol
pi = np.float64(math.pi)
rho_csol = 153889              #Densidad central del sol

#Para el punto 3 vamos a necesitar los datos del modelo de Christensen-Dalsgaard
columns = ['r/R', 'c', 'rho', 'p', 'Gamma', 'T']
ModelS = pd.read_table("/cptrho.l5bi.d.15c", sep="\s+", engine="python", names=columns,
                       skiprows=5) #Leemos los datos

#Sin embargo no necesitamos todos los datos, solo densidad y el radio
R1 = ModelS['r/R']    #Estos valores estan invertidos as√≠ que hay que darles la vuelta
R2 = pd.DataFrame(np.asarray(R1.iloc[::-1]))
r = R2[0]

RHO = ModelS['rho']*(1000)   #Estos valores estan invertidos, y en el sistema cgs.
RHO1 = pd.DataFrame(np.asarray(RHO.iloc[::-1]))#Los invertimos y pasamos al SI
rho_sol = (RHO1[0]/rho_csol)         #Valores de rho que se utilizaran (luego de
                                    #haber invertido el orden)

tabla = PrettyTable(["n", "ùúâ_1", "(-ùúâ^2 * ùëëùúÉ/ùëëùúâ)_1", "ùúåùëê/ùúå", "ùúî", "ùëÅùëõ", "ùëäùëõ" ])

for m in range (51):
    n=m/10      #Vamos a recorrer los √≠ndices de 0.1 en 0.1
    xi = 0.001
    theta = 1.0
    y = 0.0
    ddxi_sol = []
    ddxi_sol_zeros = []
    theta_sol = []
    xi_sol = []
    zeros = []  #Agregamos una lista para guardar los ceros de xi
    rr_sol = [] #Agregamos una lista para guardar los valores del radio
    M_sol = []  #Agregamos una lista para guardar los valores de la masa
    rhor_sol = [] #Agregamos una lista para guardar de la densidad
    P_sol = [] #Agregamos una lista para guardar los valores de la presi√≥n
    valores = [] #Agregamos una lista para los diferentes valores xi_1, omega,
                 #N, W y dem√°s

    for i in range(N):

        if (m%2 == 1 and theta>=0 and n!=5):

            ddxi = y/(xi**2) #Valores de la derivada
            y += -xi**2*pot(theta, n)*dxi
            theta += (y/(xi**2))*dxi
            xi += dxi
            ddxi_sol.append(ddxi)
            theta_sol.append(theta)
            xi_sol.append(xi)


            #Evaluamos cuando theta pasa por cero y guardamos el valor de xi en
            #la lista al igual que el valor que toma 'y'
            if (theta_sol[i]<0 and theta_sol[i-1]>=0):
                zeros.append(xi)
                ddxi_sol_zeros.append(ddxi)


            if (theta_sol[i]>0 and theta_sol[i-1]<=0):
                zeros.append(xi)
                ddxi_sol_zeros.append(ddxi)


        if(m%2==0 and n<5):

            ddxi = y/(xi**2) #Valores de la derivada
            y += -xi**2*pot(theta, n)*dxi
            theta += (y/(xi**2))*dxi
            xi += dxi
            ddxi_sol.append(ddxi)
            theta_sol.append(theta)
            xi_sol.append(xi)

            if (theta_sol[i]<0 and theta_sol[i-1]>=0):
                zeros.append(xi)
                ddxi_sol_zeros.append(ddxi)

            if (theta_sol[i]>0 and theta_sol[i-1]<=0):
                zeros.append(xi)
                ddxi_sol_zeros.append(ddxi)

        #Vamos a utilizar el indice n=5 para colocar el modelo del Sol
        if n==5 and i<2482:
          rr_sol = r
          rhor_sol = rho_sol
          zeros.append(1)
          ddxi_sol_zeros.append(1)



    #Analizamos los indices para los cuales hay al menos un cero asociado
    #(dentro del rango de xi evaluado)
    if len(zeros)>0:

        xi_1 = zeros[0] #Primer cero
        ddxi_1 = ddxi_sol_zeros[0] #Derivada evaluada en el primer cero
        xiddxi_1 = -pot(xi_1, 2)*ddxi_1

        #Calculamos la densidad promedio de la configuraci√≥n
        rho_ = (3*M_s)/(4*pi*pot(R_s, 3))
        #Calculamos Lambda (lmd)
        lmd = -(xi_1/3)*(1/ddxi_1)*rho_
        #Calculamos W
        W = 1/((4*pi*(n+1))*(ddxi_1)**2)
        #Calculamos presi√≥n central
        P_c = (W*G*pot(M_s, 2))/(pot(R_s, 4))
        #Calculamos razon entre densidad central y densidad promedio
        razrho = lmd/rho_

        if n==0:
            #Calculamos omega, N y K teniendo en cuenta que para n=0 N_n va al
            #infinito y por ende K_n tambien
            e = (n+1)/(n-1)
            omega = -pot(xi_1, e)*ddxi_1
            N_n = float('Inf')
            K_n = float('Inf')
            valores = [n, round(xi_1, 3), round(xiddxi_1, 3), round(razrho, 4),
                       round(omega, 3), round(N_n, 3), round(W, 3)]
            tabla.add_row(valores)

        if n==1:
            #omega para n=1 se va al infinito
            omega = float('Inf')
            s = (n-1)/n
            ss = (3-n)/n
            sss = (1-n)/(2*n)
            ssss = (3-n)/(2*n)
            N_n = (1/(n+1))*pot(((4*pi)/pot(1, n-1)), 1/n)
            K_n = N_n*G*pot(M_s,s)*pot(R_s,ss)
            b = ((n+1)*K_n)/(4*pi*G)

            valores = [n, round(xi_1, 3), round(xiddxi_1, 3), round(razrho, 4),
                       round(omega, 3), round(N_n, 3), round(W, 3)]
            tabla.add_row(valores)

            for k in range(len(xi_sol)):
              rr = pot(b, 1/2)*pot((lmd), sss)*xi_sol[k] #Calculamos radio
              rr_sol.append(rr)                   #Guardamos la soluci√≥n
              mass=-4*pi*(pot(b, 3/2))*(pot(lmd, ssss))*pot(xi_sol[k], 2)*ddxi_sol[k] #Calculamos masa
              M_sol.append(mass)                                          #Guardamos
              rhor = pot(theta_sol[k], n)         #Calculamos razon densidad/densidad central
              rhor_sol.append(rhor)        #Guardamos
              P = (W*G*pot(M_s, 2))/(pot(R_s, 4))/P_c #Calculamos presi√≥n
              P_sol.append(P)                       #Guardamos


        if (n!=0 and n!=1 and n!=5):
            #Calculemos omega, N y K
            e = (n+1)/(n-1)
            s = (n-1)/n
            ss = (3-n)/n
            sss = (1-n)/(2*n)
            ssss = (3-n)/(2*n)
            omega = -pot(xi_1, e)*ddxi_1
            N_n = (1/(n+1))*pot(((4*pi)/pot(omega, n-1)), 1/n)
            K_n = N_n*G*pow(M_s,s)*pow(R_s,ss)
            b = ((n+1)*K_n)/(4*pi*G)
            valores = [n, round(xi_1, 3), round(xiddxi_1, 3), round(razrho, 4),
                       round(omega, 3), round(N_n, 3), round(W, 3)]
            tabla.add_row(valores)

            #No queremos graficar todos los √≠ndices, pues son muchos, entonces
            #veamos aquellos despu√©s de 2.8.
            if (n>2.8):
              if n!=5:
                for k in range(len(xi_sol)):
                  rr = (pot(b, 1/2)*pot((lmd), sss)*xi_sol[k])/R_s #Calculamos radio
                  rr_sol.append(rr)                   #Guardamos la soluci√≥n
                  mass = (-4*pi*(pot(b, 3/2))*(pot(lmd, ssss))*pot(xi_sol[k], 2)*ddxi_sol[k])/M_s #Calculamos masa
                  M_sol.append(mass)                                          #Guardamos
                  rhor = pot(theta_sol[k], n)                           #Calculamos razon densidad/densidad central
                  rhor_sol.append(rhor)                                 #Guardamos
                  P = (K_n*pot(lmd, (n+1)/n)*pot(theta_sol[k], n+1))/P_c
                  P_sol.append(P)                       #Guardamos

                lb = "n = " + str(n)

                #Construimos gr√°fica para masa/masa solar  vs radio/radio solar
                fig1 = plt.figure(1)
                plt.plot(rr_sol, M_sol, label=lb)
                plt.xlim(0, 1)
                plt.ylim(0, 1)
                plt.xlabel("r/R_s")
                plt.ylabel("M/M_s")
                plt.title("Masa/Masa solar  vs Radio/Radio solar")
                plt.legend()
                plt.grid(axis='both', color='grey')
                fig1.set_size_inches(10, 8)

                #Construimos gr√°fica para densidad/densidad central  vs radio/radio solar
                fig2 = plt.figure(2)
                plt.plot(rr_sol, rhor_sol,label=lb)
                plt.xlim(0, 1)
                plt.ylim(0, 1)
                plt.xlabel("r/R_s")
                plt.ylabel("rho/rho_c")
                plt.title("Densidad/Densidad central  vs Radio/Radio solar")
                plt.legend()
                plt.grid(axis='both', color='grey')
                fig2.set_size_inches(10,8)

                #Construimos gr√°fica para presi√≥n/presi√≥n central  vs radio/radio solar
                fig3 = plt.figure(3)
                plt.plot(rr_sol, P_sol, label=lb)
                plt.xlim(0, 1)
                plt.ylim(0, 1)
                plt.xlabel("r/R_s")
                plt.ylabel("P/P_c")
                plt.title("Presi√≥n/Presi√≥n central  vs Radio/Radio solar")
                plt.legend()
                plt.grid(axis='both', color='grey')
                fig3.set_size_inches(10, 8)

        if n==5:
            lb = "Modelo Sol"

            #Construimos gr√°fica para densidad/densidad central  vs radio/radio solar
            fig2 = plt.figure(2)
            plt.plot(rr_sol, rhor_sol, linestyle="--", label=lb)
            plt.xlim(0, 1)
            plt.ylim(0, 1)
            plt.xlabel("r/R_s")
            plt.ylabel("rho/rho_c")
            plt.title("Densidad/Densidad central  vs Radio/Radio solar")
            plt.legend()
            plt.grid(axis='both', color='grey')
            fig2.set_size_inches(10, 8)

fig1
fig2
fig3
print(tabla)
print()
print()
print()
print()

"""Ya hemos resuelto los primeros dos puntos de la tarea, determinando la tabla y las graficas para las variables de la estructura estelar. Ahora, para el tercer punto, debemos discutir cu√°l es la politropa que mejor se ajusta a los datos del modelo de Christensen-Dalsgaard. Podemos observar la gr√°fica que compara $\frac{\rho}{\rho_c}$ vs $\frac{r}{R_s}$. En esta se presentan los datos del modelo de Christensen-Dalsgaard. Un vistazo r√°pido nos permite decir que la politropa se encuentra entre $n=3$ y $n=4$, espec√≠ficamente entre 3.3 y 3.6. En realidad, se puede decir que hay una combinaci√≥n de politropas que describirian adecuadamente el comportamiento de la densidad del Sol. Por ejemplo, en proximidades al centro o n√∫cleo del Sol se ajusta aparentemente bien el valor $n=3.6$, para regiones de la zona radiativa el valor $n=3.5$, en regiones cercanas a la tacoclina el valor $n=3.4$ y para regiones de la zona convectiva el valor $n=3.3$. Lo anterior cobra sentido cuando se tiene en cuenta que el indice politr√≥pico puede indicar el tipo de proceso termodin√°mico que se realiza.

Sin embargo y a pesar de dicho primer vistazo, no podr√≠a indicar en este momento y con exactitud, que tipo de relaci√≥n existe entre los valores del √≠ndice politr√≥pico y los procesos termodin√°micos que ocurren en la zona radiativa, convectiva y el n√∫cleo. Algo importante a a√±adir, es que el hecho de que el valor de $n$ no sea constante, implica que la transferencia de energ√≠a que realiza el proceso asociado a dicha n no es constante, lo cual tiene sentido pues adem√°s de existir un cambio de proceso termodin√°mico entre ambas zonas, la transferencia de energ√≠a asociada a cada proceso tambi√©n es diferente.
"""