# -*- coding: utf-8 -*-
"""Gran_Tarea3_BraitherDiaz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1US4lhI6JVS89wcvwYxzjcKWZCDkDIE0z

# Gran tarea 3

1. Estructura interna: Escoger varias masas estelares (12-16) que se encuentren en los siguientes rangos (0.9M⊙ − 1.5M⊙), (2.1M⊙ − 15M⊙), (20M⊙ − 30M⊙) y (40M⊙ − 50M⊙) que logren abarcar un amplio rango. Para cada una de las masas, describa cómo es su estructura interna como función del radio y compare las estructuras. Describa las zonas donde se presente un transporte de energía convectivo y radiativo.

Para describir la estructura interna de cada una de las masas, se utiliza el código de fortran 'zams.for'. Ingresamos los datos obtenidos a partir de la interpolación realizada en 'interpolation.py'. Se escogen las siguientes 16 masas:

* (0.9, 1.05, 1.2, 1.35)
* (2.1, 5.325, 8.55, 11.775)
* (20, 22.5, 25, 27.5)
* (40, 42.5, 45, 47,5)

Y se procede a calcular los distintos valores de la fracción X y Y, la presión central, la
temperatura central, el radio total y la luminosidad para posteriormente introducirlos en el código de fortran. Una vez que se obtienen los resultados de fortran, se introducen en el código 'read_variables.py' de forma que sea sencillo leer los resultados para poder comparar las estructuras y describir las zonas donde se presente transporte de energía convectivo y radiativo. Sin embargo, este método no funciona, pues el código 'convert_variables.py' parece no funcionar para versiones más actuales de MacOS (intenté de muchas formas para que fuese compatible y sin embargo no lo conseguí), por lo tanto, se optó por otro método. Creando a mano archivos secundarios auxiliares solo con los datos numéricos.

2. El diagrama Hertzsprung-Russell (diagrama HR) es un gráfico que muestra la relación que hay entre la luminosidad/magnitud absoluta y la temperatura efectiva/clasificación espectral de las estrellas. A partir de los archivos de salida, construya el diagrama HR para estrellas ZAMS considerando una muestra importante de estrellas.
"""

#Importemos algunas librerias
import astropy
import math
import numpy as np
import matplotlib.pyplot as plt
import os
import pandas as pd

from astropy import units as u
from astropy import constants as const
from prettytable import PrettyTable
from scipy.interpolate import InterpolatedUnivariateSpline as spline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

"""
  Interpolación de la tabla de datos para los obtener 'initial guesses'
  de forma precisa.
"""

M_s = np.float64(const.M_sun.cgs) #Masa sol
R_s = np.float64(const.R_sun.cgs) #Radio sol

# -- Open the file containing the information of radial-dependent variables
#    of the selected stellar mass.
M, X, Y, logL, logTe, R10, Tc6, rhoc, logPc = np.loadtxt('table.dat',\
    unpack=True)

# -- Get variables in Gaussian units
L  = 10**logL
Te = 10**logTe
R  = R10*1e10
Tc = Tc6*1e6
Pc = 10**logPc

# -- Interpolation range
fM = np.linspace(0.01,60,100000)

# -- Smooth interpolation using spline interpolating function
fX   =  spline(M,X)
fY   =  spline(M,Y)
fL   =  spline(M,L)
fPc  =  spline(M,Pc)
fTe  =  spline(M,Te)
fTc  =  spline(M,Tc)
fR   =  spline(M,R)
frho =  spline(M,rhoc)

# -- Function to get proper initial guesses variables
def interpolation(M):
    XX = float(fX(M))  # -- Conversion to floats
    YY = float(fY(M))
    #print('Mass =  {}'.format(M))
    #print('X, Y =  %.2f %.2f'%(XX,YY))
    #print('Pc   =  %.4e'%(fPc(M)))
    #print('Tc   =  %.4e'%(fTc(M)))
    #print('R    =  %.4e'%(fR(M)))
    #print('L    =  %.3f'%(fL(M)))
    # -- Return variables
    return M, XX, YY, fPc(M), fTc(M), fR(M), fL(M), fTe(M)


# Llamado de la function
#d = interpolation(40)
#print(d[1])


#Lista de 16 masas que se van a utilizar
lmasas = [0.9, 1, 1.2, 1.35, 2.1, 5.325, 8.55, 11.775, 20, 22.5, 25, 27.5, 40, 42.5, 45, 47.5]
#lTeff = []
#lLum = []
#1.05 no converge
#Aprovecharé una de las herramientas del sistema operativo de Apple Mac OS para automatizar el llenado
#de datos en fortran
f = open('estructuraMasas.txt', 'w')
f.write('tell application "Terminal"')
f.write('  \n activate')
f.write('  \n set currentTab to do script ("cd desktop/zams/")')
for i in range (len(lmasas)):
    values = interpolation(lmasas[i])
    f.write('  \n do script ("./output") in currentTab')
    f.write('  \n delay 8')
    f.write('  \n do script ("' + str(values[0]) + '") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("' + str(values[1]) + '") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("' + str(values[2]) + '") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("' + str(values[3]) + '") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("' + str(values[4]) + '") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("' + str(values[5]) + '") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("' + str(values[6]) + '") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("M' + str(i) + '.txt") in currentTab')
    f.write('  \n delay 1')
    f.write('  \n do script ("N") in currentTab')
    f.write('  \n delay 1')
f.write("\nend tell")
f.close()

#De esta forma se obtienen 16 documentos .txt con la información de la estructura interna para las
#distintas masas en función del radio. Ahora se deben pasar los resultados por el código 'read_variables.py'.

"""
  Python script para leer los datos de salida de zams.for, traducirlos
  al lenguaje de Python y obtener las variables de estructura.
"""

# Debido a que no funciono "convert_variables.sh" fue necesario utilizar dos archivos distintos, uno para
#cada tabla. La separación la realicé a mano pasando de los datos de un archivo a otro. Lo anterior se realiza para cada una de las 16 masas.
for i in range(16):
    #Necesitamos convertir a notación cientifica para poder leer los documentos y para esto cambie el código de
    #"convert_variables.sh".Al final lo adjuntare como un comentario.
    label0 = "0M"+str(i)+".txt"
    label1 = "1M"+str(i)+".txt"
    command0 = 'bash convert_variables.sh ' + label0
    command1 = 'bash convert_variables.sh ' + label1
    os.system(command0)
    os.system(command1)

    # El archivo de salida generado se lee con np.loadtxt() desempaquetando
    # todas las variables contenidas. Se puede observar como se dividieron los datos en dos partes.
    idx,M0,r0,P0,T0,rho0,L0 = np.loadtxt(label0, unpack=True) #Primera parte
    idx,EPS,OP,Lc0,LT0,DEL0,DELAD0,DELRAD0 = np.loadtxt(label1, usecols=[0,1,2,3,4,5,6,7], unpack=True) #Segunda parte

    # Se toman las inversas correspondientes y se deja en unidades CGS.
    # No prestar detalle si llega a presentarse un overflow (valor excesivamente
    # grande para el caso de los deltas. No afecta.)
    M =   1 - M0
    r =   (10**r0)/R_s
    P =   10**P0
    T =   10**T0
    rho = 10**rho0
    L   = 10**L0
    Lc     = 10**Lc0
    DEL    = 10**DEL0
    DELAD  = 10**DELAD0
    DELRAD = 10**DELRAD0

    #Con el fin de comparar las diferentes estructuras internas, se proponen las gráficas de algunos valores
    #respecto al radio de la configuración, como lo es la masa y la temperatura.

    lb = "M = " + str(lmasas[i]) + "M⊙"
    fig1 = plt.figure(1)
    plt.plot(r, M, label=lb)
    plt.xlabel("r/R_s")
    plt.ylabel("M/M_s")
    plt.title("Masa/Masa solar  vs Radio/Radio solar")
    plt.legend()
    plt.grid(axis='both', color='grey')


    lb = "M = " + str(lmasas[i]) + "M⊙"
    fig2 = plt.figure(2)
    plt.plot(r, T, label=lb)
    plt.xlabel("r/R_s")
    plt.ylabel("T")
    plt.title("Temperatura vs Radio/Radio solar")
    plt.legend()
    plt.grid(axis='both', color='grey')


    lb = "M = " + str(lmasas[i]) + "M⊙"
    fig3 = plt.figure(3)
    plt.plot(r, Lc, label=lb)
    plt.xlabel("r/R_s")
    plt.ylabel("T")
    plt.title("Luminosidad convectiva vs Radio/Radio solar")
    plt.legend()
    plt.grid(axis='both', color='grey')


    lb = "M = " + str(lmasas[i]) + "M⊙"
    fig4 = plt.figure(4)
    plt.plot(M, EPS, label=lb)
    plt.xlabel("M/M⊙")
    plt.ylabel("EPS")
    plt.title("Masa vs Tasa generación de energía")
    plt.legend()
    plt.grid(axis='both', color='grey')

    #En muy pocas palabras, un gradiente bajo de temperatura, implica zona convectiva y un gradiente alto
    #implica zona radiativa.
#Ahora construyamos el diagrama HR. Para esto vamos a tomar los datos de luminosidad/magnitud absoluta
#y de temperatura efectiva que encontramos al correr el programa de fortran y vamos a graficarlos, no sin antes
#calcular el logaritmo de la luminosidad.
lTeff = []
logLum = []
Lum = []
lm = []
for n in range (500):
    m = n/10
    lm.append(m)
    values = interpolation(m)
    lTeff.append(values[7])
    logLum.append(np.log(values[6]))
    Lum.append(values[6])


fig5 = plt.figure(5)
plt.scatter(lTeff, logLum, marker="*")
plt.xlabel("Temperatura (K)")
plt.ylabel("Luminosidad (log(L))")
plt.title("Diagrama HR (Main Sequence)")
plt.grid(axis='both', color='grey')



#Para el último punto queremos conocer el exponente alpha. Podemos observar que realizando la gráfica en escala
#logarítmica se obtiene un resultado muy cercano a una linea recta, por lo tanto, es posible realizar una
#regresión lineal para obtener alpha.
#En general para diversos valores de la masa entre 0.1 M⊙ y 50 M⊙
fig6 = plt.figure(6)
plt.plot(lm, Lum, marker="*")
plt.xlabel("Masa (M/M⊙)")
plt.ylabel("Luminosidad (L/L⊙")
plt.xscale("log")
plt.yscale("log")
plt.title("Masa vs Luminosidad (0.1M⊙ - 50M⊙)")
plt.grid(axis='both', color='grey')

#Para el intervalo de masas de 0.2M⊙ < M < 0.5M⊙
logLum1 = []
logm1 = []
m = 0.2
for k in range (100):
    m += 0.003
    values = interpolation(m)
    logm1.append(np.log(m))
    logLum1.append(np.log(values[6]))

fig7 = plt.figure(7)
plt.plot(logm1, logLum1, marker="*")
plt.xlabel("Masa (M/M⊙)")
plt.ylabel("Luminosidad (L/L⊙")
plt.title("Masa vs Luminosidad (0.2M⊙ - 0.5M⊙)")
plt.grid(axis='both', color='grey')


#Para el intervalo de masas de 0.5M⊙ < M < 2.0M⊙
logLum2 = []
logm2 = []
m = 0.5
for k in range (100):
    m += 0.015
    values = interpolation(m)
    logm2.append(np.log(m))
    logLum2.append(np.log(values[6]))

fig8 = plt.figure(8)
plt.plot(logm2, logLum2, marker="*")
plt.xlabel("Masa (M/M⊙)")
plt.ylabel("Luminosidad (L/L⊙")
plt.title("Masa vs Luminosidad (0.5M⊙ - 2.0M⊙)")
plt.grid(axis='both', color='grey')

#Para el intervalo de masas de 2.0M⊙ < M < 50M⊙
logLum3 = []
logm3 = []
m = 2.0
for k in range (50):
    m += 0.96
    values = interpolation(m)
    logm3.append(np.log(m))
    logLum3.append(np.log(values[6]))

fig9 = plt.figure(9)
plt.plot(logm3, logLum3, marker="*")
plt.xlabel("Masa (M/M⊙)")
plt.ylabel("Luminosidad (L/L⊙")
plt.title("Masa vs Luminosidad (2.0M⊙ - 50M⊙)")
plt.grid(axis='both', color='grey')

"""#'convert_variables.sh' editado por mi

#!/bin/bash

progname=$(basename $0)


# Function to print in console about usage
usage () {
  varout=$(cat << EOF

  Programa para obtener variables de estructura dependientes del radio
  para un archivo de salida de zams.for.

  Uso:  bash $progname Nombre_del_archivo
        bash $progname M01.txt

  Al correrlo, se genera un archivo con la información de:
    index M r P T rho L index EPS OP Lc LC/LTOT DEL DELAD DELRAD

EOF
  )
  echo "$varout"
}


# If statement when there are not enough arguments to the script
if [ $# -lt 1 ] || [ $# -ge 2 ] #|| [ $# -eq 3 ]
then
  usage
  if test $# -eq 0
  then
      exit 0
  else
      exit 1
  fi
  exit 0
fi



# Name of the output file
FILE=$1



# ---- PROGRAM ----

# Separate mixed-in-one columns into two columns
#   example:    200-20.0000   -->   200 -20.0000
sed -i '' -E 's/([0-9])-([0-9])/\1 -\2/g' $FILE

# Change scientific notation D+/D- to e+/e- to read in python
#   example:    3.953776D+01   -->   3.953776e+01
perl -pi -e 's/D-/e-/g; s/D+/e+/g' $FILE

"""

